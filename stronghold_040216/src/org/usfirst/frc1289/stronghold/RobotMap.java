// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1289.stronghold;

import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    
    public static DigitalInput armLimitSwitch1; 			// DIG 4
    public static Solenoid armPneumaticinout;				// PNU 3
    public static Solenoid armPneumaticupdown;				// PNU 1
   // public static Solenoid sallyportSpneumatic;				// PNU 7
    public static Solenoid BallShooter;
    public static SpeedController ballHandlerBallMotorL;	// PWM 5 
    public static SpeedController ballHandlerBallMotorR;	// PWM 6
    public static AnalogInput ballHandlerSwitch;			// ANL 2
    public static Solenoid ballHandlerBallsolenoid;			// PNU 0
    public static SpeedController winchWinchMotor;			
    public static SpeedController winchTapeMotor;			
    public static SpeedController driveTrainMotorLeft;		// PWM 0
    public static SpeedController driveTrainMotorRight;		// PWM 1

    public static RobotDrive driveTrainRobotDrive21;
    public static Encoder driveTrainQuadLeft;				// DIG 0,1
    public static Encoder driveTrainQuadRight;				// DIG 2,3
    public static AnalogInput driveTrainUltra1;				// ANL 0
    public static AnalogInput driveTrainUltra2;				// ANL 1
    public static Servo cameraUpDown;						// PWM 6
    public static Servo cameraLeftRight;					// PWM 7
    public static PIDController UltraSoundPID;
    public static PIDController EncoderPID;
    public static PIDController CompassPID;
    
    public static AHRS navx;
    static final double kToleranceDegrees = 2.0f;
    


    public static void init() {
        

        armLimitSwitch1 = new DigitalInput(4);
        LiveWindow.addSensor("Arm", "Limit Switch 1", armLimitSwitch1);
        
        armPneumaticinout = new Solenoid(0, 4);
        LiveWindow.addActuator("Arm", "Pneumatic in out", armPneumaticinout);
        
        armPneumaticupdown = new Solenoid(0, 7);
        LiveWindow.addActuator("Arm", "Pneumatic up down", armPneumaticupdown);
        
        //sallyportSpneumatic = new Solenoid(0, 7);
        //sallyportSpneumatic = new DoubleSolenoid(0, 2, 4);
       // LiveWindow.addActuator("Sallyport", "S pneumatic", sallyportSpneumatic);
        BallShooter = new Solenoid(0,1);
        LiveWindow.addActuator("Ball Handler", "Ball Shooter", BallShooter);
        
        ballHandlerBallMotorL = new Talon(3);
        LiveWindow.addActuator("Ball Handler", "Ball Motor L", (Talon) ballHandlerBallMotorL);
        
        ballHandlerBallMotorR = new Talon(4);
        LiveWindow.addActuator("Ball Handler", "Ball Motor R", (Talon) ballHandlerBallMotorR);
        
        ballHandlerSwitch = new AnalogInput(2);
        LiveWindow.addSensor("Ball Handler", "Light Sensor", ballHandlerSwitch);
        
        ballHandlerBallsolenoid = new Solenoid(0,0);
        LiveWindow.addActuator("Ball Handler", "Ballsolenoid", ballHandlerBallsolenoid);
        
        /*
        winchWinchMotor = new Talon(2);
        LiveWindow.addActuator("Winch", "Winch Motor", (Talon) winchWinchMotor);
        
        winchTapeMotor = new Talon(5);
        LiveWindow.addActuator("Winch", "Tape Motor", (Talon) winchTapeMotor);
        */
        driveTrainMotorLeft = new Talon(0);
        LiveWindow.addActuator("DriveTrain", "MotorLeft", (Talon) driveTrainMotorLeft);
        
        driveTrainMotorRight = new Talon(1);
        LiveWindow.addActuator("DriveTrain", "MotorRight", (Talon) driveTrainMotorRight);
        
     
        driveTrainRobotDrive21 = new RobotDrive(driveTrainMotorLeft, driveTrainMotorRight);
        
        driveTrainRobotDrive21.setSafetyEnabled(true);
        driveTrainRobotDrive21.setExpiration(0.1);
        driveTrainRobotDrive21.setSensitivity(0.5);
        driveTrainRobotDrive21.setMaxOutput(1.0);

        driveTrainRobotDrive21.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
        //driveTrainRobotDrive21.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
        //driveTrainRobotDrive21.setInvertedMotor(RobotDrive.MotorType.kFrontRight, true);
        
        // Define the Quadrature Encoders
        // Distance Per Pulse = Diameter of Wheel (8.5in * Pi)/360 pulses per revolution = .0741765in
        // NOTE right quadrature encoder turns in opposite direction from left.
        driveTrainQuadLeft = new Encoder(0, 1, false, EncodingType.k4X);
        LiveWindow.addSensor("DriveTrain", "QuadLeft", driveTrainQuadLeft);
        driveTrainQuadLeft.setDistancePerPulse(.0741765);
        driveTrainQuadLeft.setPIDSourceType(PIDSourceType.kDisplacement);
        
        driveTrainQuadRight = new Encoder(2, 3, true, EncodingType.k4X); 
        LiveWindow.addSensor("DriveTrain", "QuadRight", driveTrainQuadRight);
        driveTrainQuadRight.setDistancePerPulse(.0741765);
        driveTrainQuadRight.setPIDSourceType(PIDSourceType.kDisplacement);
        
        driveTrainUltra1 = new AnalogInput(0);
        LiveWindow.addSensor("DriveTrain", "Ultra1", driveTrainUltra1);
        driveTrainUltra2 = new AnalogInput(1);
        LiveWindow.addSensor("DriveTrain", "Ultra2", driveTrainUltra2);
        
        /*
          cameraUpDown = new Servo(6);
        
        LiveWindow.addActuator("Camera","Up Down",cameraUpDown);
        
        cameraLeftRight = new Servo(7);
        LiveWindow.addActuator("Camera","Left Right",cameraLeftRight);
        */
        
        navx = new AHRS(SPI.Port.kMXP);
          
        
        UltraSoundPID = new PIDController(1,0.0,0.0, driveTrainUltra1, new myPIDOutput());
        LiveWindow.addActuator("Ultra Sound PID", "Other Words", UltraSoundPID);
        UltraSoundPID.setContinuous(false);
        UltraSoundPID.setAbsoluteTolerance(0.1);
        UltraSoundPID.setOutputRange(-1.0, 1.0);
        
        EncoderPID = new PIDController (0.3,0.0,0.0, driveTrainQuadLeft, new myPIDOutput());
        LiveWindow.addActuator("Encoder PID",  "", EncoderPID);
        EncoderPID.setContinuous(false);
        EncoderPID.setAbsoluteTolerance(5);
        EncoderPID.setOutputRange(-1.0, 1.0);
        
        CompassPID = new PIDController (0.3,0.0,0.0, navx, new myPIDOutput());
        LiveWindow.addActuator("Compass PID",  "", CompassPID);
        CompassPID.setInputRange(-180.0f,  180.0f);
        CompassPID.setOutputRange(-1.0, 1.0);
        CompassPID.setAbsoluteTolerance(kToleranceDegrees);
        CompassPID.setContinuous(true);
        
    }
}
class myPIDOutput implements PIDOutput {
	@Override
	public void pidWrite(double output) {
		SmartDashboard.putNumber("PIDOutput Value", output);
		Robot.driveTrain.moverobot(output);
	}

}

 

