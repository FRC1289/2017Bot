// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1289.stronghold.subsystems;

import org.usfirst.frc1289.stronghold.RobotMap;
import org.usfirst.frc1289.stronghold.commands.*;

import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class DriveTrain extends Subsystem {

	//Variables used to calculspate Jerk
	private float lastXValue = 0;
	private float lastYValue = 0;
	
    private final SpeedController motorLeft = RobotMap.driveTrainMotorLeft;
    private final SpeedController motorRight = RobotMap.driveTrainMotorRight;
    private final RobotDrive robotDrive21 = RobotMap.driveTrainRobotDrive21;
    private final Encoder quadLeft = RobotMap.driveTrainQuadLeft;
    private final Encoder quadRight = RobotMap.driveTrainQuadRight;
    private final AnalogInput ultra1 = RobotMap.driveTrainUltra1;
    private final AHRS navx = RobotMap.navx;

	public class MyPidOutput implements PIDOutput {
	    @Override
	    public void pidWrite(double output) {
	    motorLeft.set(output);
	    motorRight.set(output);
		}
	}
	
	/*
	 * public class DTPidSource extends PIDSource {
	
		
		double PassEncoder() {
			
			return RobotMap.driveTrainQuadLeft.get();
		}
	}
	*/
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {

        setDefaultCommand(new DriveWithJoystick());

    }
    
    public void ArcadeDrive (Joystick stick){
    	
    	double x,y;
    	
    	// Get the Joystick X and Y values
    	x=stick.getX();
    	y=-stick.getY();
    	
    	// Test the trigger button. If pressed then cut the value of X and Y by half
    	if (stick.getRawButton(1)) {
    		x=x*1;
    		y=y*1;
    	}

    	else{
    		
    		x=x*.75;
    		y=y*.75;
    	}
    	// Send the final X and Y value to the arcade drive to set the motor speed.
    	robotDrive21.arcadeDrive(x,y);
   }

    // Read an ultra sound sensor 
    //NOTE: The assumption is there are four UltraSound sensors across the front of the robot
    public double getUltra () {
    	
    	/*switch (Channel) {
    		case 1: return ultra1.getAverageVoltage();
    		case 2: return ultra2.getAverageVoltage();
    		case 3: return ultra3.getAverageVoltage();
    		case 4: return ultra4.getAverageVoltage();
    		default: return -1;
    	}*/
    	return ultra1.getValue();
    }
    
    // Read the encoders on the drive train. 
    // Assumptions is there are two, one on each transmission; left and right
    // If passed a 1 returns the left side, if passed 2 returns right side.
    public double getquad (int channel) {
    	
    	switch (channel) {
    		case 1: return quadLeft.getDistance();
    		case 2: return quadRight.getDistance();
    		default: return -1;
    	}
    }

    // Sets the motor speed of all motors to the desired setting
    public void moverobot (double speed){
     motorLeft.set(speed);
     motorRight.set(speed);
     
    }

    // Sets the motor speed in opposite directions so robot turns
    public void turnrobot(double speed) {
    	motorLeft.set(speed);
    	motorRight.set(-speed);
    }

    // This method returns true if the current heading of the robot is 
    // more than 2 degrees different from the desired heading.
    public boolean HeadingDeviation(float GoalHeading) {
    	
    	float CurrentHeading = navx.getFusedHeading();
    	
    	if (Math.abs(CurrentHeading-GoalHeading) > 2) return true; else return false;
    }
    
    // This method returns true if the change in movement is 
    // greater than a threshold value
    public boolean Jerk() {
    	float JerkThreshold = 5;
    	float CurrentXJerk = navx.getDisplacementX();
    	float CurrentYJerk = navx.getDisplacementY();
    	float XJerk, YJerk;
    	
    	XJerk = Math.abs(lastXValue - CurrentXJerk);
    	YJerk = Math.abs(lastYValue - CurrentYJerk);
    	
    	lastXValue = CurrentXJerk;
    	lastYValue = CurrentYJerk;
    	
    	if ((XJerk > JerkThreshold) || (YJerk > JerkThreshold)) return true; else return false;
    	
    }
    
    protected void usePIDOutput(double d) {
    	motorLeft.set(d);
    	motorRight.set(-d);
    }
    
    protected double returnPIDInput() {
        return ultra1.getAverageVoltage();
    }

}

